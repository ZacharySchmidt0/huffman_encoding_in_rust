/*
 * Author: Zachary Schmidt
 * Date: Jan 21, 2023
 * All code was developed solely by myself, with only marginal use of ChatGPT to assist productivity.
 * 
 * This file is my solution to the problem posed by Garmin to prospective co-op students.
 * It contains functions used to compress and decompress a byte array using Huffman coding.
 * When run by itself, it takes an example u8 array, compresses it, descompresses it, and compares
 * the original to the processed, noting any differences. The compression ratio is also printed.
*/

use std::collections::HashMap;

/// Iterates through the data_ptr array and counts the number of occurrences of each byte value.
/// Stores the result in a HashMap.
/// 
/// # Arguments
/// * 'data_ptr' - Pointer to u8 array
/// 
/// # Returns
/// * HashMap with byte value as key, and the number of times that value appears in the array as value.
/// 
fn count_byte_occurrences(data_ptr: &[u8]) -> HashMap<&u8, u32> {
    let mut value_occurrences: HashMap<&u8, u32> = HashMap::new();

    for byte_value in data_ptr {
        if !value_occurrences.contains_key(byte_value) {
            value_occurrences.insert(byte_value, 1);
        } else {
            *value_occurrences.entry(byte_value).or_insert(1) += 1;
        }
    }

    value_occurrences
}

/// Swaps the key and value for the HashMap returned from count_byte_occurrences. Value becomes
/// a Vec<u8> that could have multiple entries (if multiple byte values occurred the same number of times
/// in the array). Useful to iterate through byte values in order of number of occurrences.
/// 
/// # Arguments
/// * 'value_occurrences' - HashMap generated by count_byte_occurrences(). Maps byte value to number of occurrences.
/// 
/// # Returns
/// * HashMap that maps number of occurrences to byte value. Key = # of occurrences, Value = Vec with all byte values
///   with that number of occurrences (in arbitrary order).
/// 
fn swap_occurrences_map(value_occurrences: HashMap<&u8, u32>) -> HashMap<u32, Vec<u8>> {
    let mut occurrences_value: HashMap<u32, Vec<u8>> = HashMap::new();
    for byte_value in value_occurrences.keys() {
        let occurrences = &value_occurrences[byte_value];

        if !occurrences_value.contains_key(occurrences) {
            // create Vec with one element and insert with key
            let mut vec: Vec<u8> = Vec::new();
            vec.push(**byte_value);
            occurrences_value.insert(*occurrences, vec);
        } else {
            // Vec already exists, push to it
            let mut vec: Vec<u8> = Vec::new();
            vec.push(**byte_value);
            occurrences_value.entry(*occurrences).or_insert(vec).push(**byte_value);
        }
    }

    occurrences_value
}

/// Generates the compression and decompression tables which maps a u8 byte value to a bitstring (or vice versa).
/// Each byte value is mapped to a bitstring with some >= 0 number of zeros followed by exactly one 1. 
/// More frequent occurring byte values are mapped to shorter bitstrings (fewer leading zeros).
/// 
/// # Arguments
/// * 'occurrences_value' - HashMap generated by swap_occurrences_map(). Maps number of occurrences to u8 byte value.
/// 
/// # Returns
/// * tuple: first element = compression table, second element = decompression table. The two tables simply swap
///   key and value entries.
/// 
fn create_tables(occurrences_value: HashMap<u32, Vec<u8>>) -> (HashMap<u8, String>, HashMap<String, u8>) {
    let mut vec: Vec<u32> = occurrences_value.keys().cloned().collect();
    vec.sort();
    vec.reverse();  // most frqeuently occurring byte first

    let mut num_zeros = 0;

    let mut compression_table: HashMap<u8, String> = HashMap::new();
    let mut decompression_table: HashMap<String, u8> = HashMap::new();

    for occurrences in vec {
        for byte_value in occurrences_value.get(&occurrences).unwrap() {
            let encoding = std::iter::repeat("0").take(num_zeros).collect::<String>() + "1";

            compression_table.insert(*byte_value, encoding.clone());
            decompression_table.insert(encoding, *byte_value);
            
            num_zeros += 1;
        }
    }

    (compression_table, decompression_table)
}

/// Performs compression on the byte array. Changes are made directly to the array elements, and the size
/// of the new array is returned (which must be paid attention to since the array likely changed size).
/// 
/// # Arguments
/// * 'data_ptr' - pointer to the byte array, values will be overridden
/// * 'data_size' - size of the original array
/// * 'compression_table' - HashMap that maps byte value to bitstring. Generated by create_tables()
/// 
/// # Returns
/// * tuple: first element = size of the new array (guaranteed to be <= size of original array),
///   second element = compression_table, third_element = decompression_table
/// Note: I'm aware that returning a tuple doesn't conform to the specification, but it is necessary
///       for me to perform decompression (and probably makes sense regardless)
/// 
fn compress(data_ptr: &mut[u8], data_size: usize) -> (usize, HashMap<u8, String>, HashMap<String, u8>) {
    let value_occurrences = count_byte_occurrences(&data_ptr);
    let occurrences_value = swap_occurrences_map(value_occurrences);
    let (compression_table, decompression_table) = create_tables(occurrences_value);

    let byte_chunk_size = 3; // number of byte array elements to process at once (buffer size)
    let mut indx = 0;  // to index data_ptr
    let mut binary_str = String::new(); // acts as a buffer to store bitstring to be processed at a time

    for i in (0..data_size).step_by(byte_chunk_size) {
        for j in 0..byte_chunk_size {
            if i + j < data_size {
                // read byte value, lookup in compression_table, and add to string buffer
                let raw_val = data_ptr[i + j];
                let encoded_val = &compression_table[&raw_val];
                binary_str += &encoded_val;
            }
        }

        // need to add 8 bits (1 byte) to the data_ptr at a time
        for start_indx in (0..binary_str.len()).step_by(8) {
            if start_indx + 8 <= binary_str.len() {
                // >= 8 bits (1 byte) to work with: convert bitstring to u8 and place in data_ptr
                let end_indx = start_indx + 8;

                let conv_str = &binary_str[start_indx..end_indx];
                let encoded_val = u8::from_str_radix(conv_str, 2).unwrap();
                data_ptr[indx] = encoded_val;
                indx += 1;
            } else {
                // < 8 bits to work with, need to store leftover in string buffer (binary_str) and read next chunk
                binary_str = binary_str[start_indx..].to_string();
            }

            if start_indx + 8 == binary_str.len() {
                // if no leftover bits, clear the string buffer
                binary_str = "".to_string();
            }
        }
    }

    // could have leftover bits (potentially more than 8 if last byte is encoded to bitstring with
    // more than 7 zeros) -> add trailing zeros to bitstring to make bitstring_len % 8 == 0, then convert
    // every 8 bits to byte and place in data_ptr
    let conv_str = binary_str.to_string();
    let str_len = conv_str.len();
    let conv_str = conv_str + &std::iter::repeat("0").take(8 - str_len % 8).collect::<String>();
    for start_indx in (0..conv_str.len()).step_by(8) {
        let encoded_val = u8::from_str_radix(&conv_str[start_indx..start_indx+8], 2).unwrap();
        data_ptr[indx] = encoded_val;
        indx += 1;
    }

    (indx, compression_table, decompression_table)
}


/// Performs decompression on a byte array given the corresponding decompression table. Changes do not
/// override the underlying array, they are instead returned in a Vec.
/// 
/// # Arguments
/// * 'encoded_data' - pointer to compressed data stored in u8 array
/// * 'data_size' - size of the compressed data array
/// * 'decompression_table' - HashMap that maps bitstrings (compressed) to byte value (decompressed)
/// 
/// # Returns
/// * Vec<u8> with decompressed data
/// 
fn decompress(encoded_data: &[u8], data_size: usize, decompression_table: HashMap<String, u8>) -> Vec<u8> {
    let mut raw_data: Vec<u8> = Vec::new();

    let mut str_buff = String::new();
    let mut count = 0;

    for byte in encoded_data {

        // reached end of compressed data
        if count > data_size {
            break;
        }

        // convert byte value to bitstring (with leading zeros)
        str_buff += &format!("{:08b}", byte);

        let mut encoded_str = String::new();

        for char in str_buff.chars() {
            encoded_str.push(char);
            if char == '1' {
                // all of the bits in encoded_str are the encoded bitstring for a number
                let raw_val = decompression_table[&encoded_str];
                raw_data.push(raw_val);
                encoded_str = "".to_string();
            }
        }
        str_buff = encoded_str;
        count += 1;
    }

    raw_data
}

/// Prints useful information about compression ratio (how much smaller compressed array is compared to
/// original), and all the original data side-by-side with data that was compressed then decompressed (should
/// be the same).
/// 
/// # Arguments
/// * 'compressed_size' - size of the compressed array
/// * 'original_size' - size of the original array
/// * 'original_data' - original byte array
/// * 'processed_data' - data that was compressed then decompressed
/// 
/// # Returns
/// None, prints information to screen
/// 
fn print_stats(compressed_size: usize, original_size: usize, original_data: &[u8], processed_data: Vec<u8>) {
    let comp_ratio = compressed_size as f64/original_size as f64;
    println!("Compression ratio: {}", comp_ratio);

    println!("{:<10}---{:^16}", "Original", "Processed");
    for i in 0..original_size {
        println!("{:^9}---{:10}", original_data[i], processed_data[i]);
        if original_data[i] != processed_data[i] {
            println!("BAD");
        }
    }
}

fn main() {
    const ORIGINAL_SIZE: usize = 50;
    let mut data: [u8; ORIGINAL_SIZE] = [
        34, 12, 78, 5, 92, 34, 20, 76, 92, 8, 45, 12, 106, 56, 78, 92, 34, 20, 45, 106,
        18, 92, 34, 76, 5, 56, 106, 45, 20, 8, 92, 78, 12, 92, 20, 56, 34, 76, 106, 5,
        92, 8, 34, 45, 12, 122, 0, 106, 1, 89
    ];

    let original_data = data.clone();

    let data_size = data.len();
    let (new_size, compression_table, decompression_table) = compress(&mut data, data_size);

    let processed_data = decompress(&data, new_size, decompression_table.clone());

    print_stats(new_size, ORIGINAL_SIZE, &original_data, processed_data);
}